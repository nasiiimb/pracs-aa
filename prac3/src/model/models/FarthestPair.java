package model.models;

import main.Controller;
import main.Notify;
import model.Point;

import java.util.*;


public class FarthestPair
{
    private final Controller controller;
    private Point[] farthestPoints;
    private static boolean cancel;

    public FarthestPair(Controller controller, Point[] points)
    {
        this.controller = controller;
        this.farthestPoints = null;
        this.cancel = false;
        new FarthestPairThread(points);
    }


    /**
     * Stops the model.
     */
    public void stopModel() { this.cancel = true; }


    /**
     * Returns the current polygons generated by the model.
     */
    public Point[] getFarthestPoints() { return farthestPoints; }


    private class FarthestPairThread extends Thread
    {
        private final Point[] points;

        public FarthestPairThread(Point[] points)
        {
            this.points = points;
            this.start();
        }

        @Override
        public void run()
        {
            long startFarthestPoint = System.currentTimeMillis();
            farthestPoints = findFarthestPair(points);
            long endFarthestPoint = System.currentTimeMillis();
            System.out.println("Farthest Point: " + (endFarthestPoint - startFarthestPoint) + " ms");
            System.out.println("Parell més llunyà: " + farthestPoints[0] + " <-> " + farthestPoints[1]);

            controller.notify(Notify.PROCESS_FINISHED);
            controller.notify(Notify.PAINT);
        }
    }


    public static Point[] findFarthestPair(Point[] points)
    {
        if (points.length < 2) return null;
        if (points.length == 2) return new Point[]{points[0], points[1]};

        List<Point> hull = convexHull(points);
        int n = hull.size();
        double maxDist = 0.0;
        Point p1 = null, p2 = null;

        int j = 1;
        for (int i = 0; i < n; i++)
        {
            while (area2(hull.get(i), hull.get((i + 1) % n), hull.get((j + 1) % n)) >
                    area2(hull.get(i), hull.get((i + 1) % n), hull.get(j))) {
                j = (j + 1) % n;
            }
            double dist = hull.get(i).distanceTo(hull.get(j));
            if (dist > maxDist)
            {
                maxDist = dist;
                p1 = hull.get(i);
                p2 = hull.get(j);
            }
        }
        return new Point[]{p1, p2};
    }


    private static List<Point> convexHull(Point[] points)
    {
        List<Point> pts = new ArrayList<>(Arrays.asList(points));
        pts.sort(Comparator.comparingDouble((Point p) -> p.x).thenComparingDouble(p -> p.y));

        List<Point> lower = new ArrayList<>();
        for (Point p : pts)
        {
            while (lower.size() >= 2 && area2(lower.get(lower.size()-2), lower.getLast(), p) <= 0)
            {
                lower.removeLast();
            }
            lower.add(p);
        }

        List<Point> upper = new ArrayList<>();
        for (int i = pts.size() - 1; i >= 0; i--)
        {
            Point p = pts.get(i);
            while (upper.size() >= 2 && area2(upper.get(upper.size()-2), upper.getLast(), p) <= 0)
            {
                upper.removeLast();
            }
            upper.add(p);
        }

        lower.removeLast();
        upper.removeLast();
        lower.addAll(upper);
        return lower;
    }


    private static double area2(Point a, Point b, Point c)
    {
        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    }
}
