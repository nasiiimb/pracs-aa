package model.models;

import main.Controller;
import main.Notify;
import model.Point;


public class ClosestPairBruteForce
{
    private final Controller controller;
    private Point[] closestPoints;
    private static boolean cancel;

    public ClosestPairBruteForce(Controller controller, Point[] points)
    {
        this.controller = controller;
        this.closestPoints = null;
        this.cancel = false;
        new ClosestPairBruteForceThread(points);
    }


    /**
     * Stops the model.
     */
    public void stopModel() { this.cancel = true; }


    /**
     * Returns the current polygons generated by the model.
     */
    public Point[] getClosestPoints() { return closestPoints; }


    private class ClosestPairBruteForceThread extends Thread
    {
        private final Point[] points;

        public ClosestPairBruteForceThread(Point[] points)
        {
            this.points = points;
            this.start();
        }

        @Override
        public void run()
        {
            long startBrute = System.currentTimeMillis();
            closestPoints = findClosestPair(points);
            long endBrute = System.currentTimeMillis();
            System.out.println("Brute Force: " + (endBrute - startBrute) + " ms");

            controller.notify(Notify.PROCESS_FINISHED);
        }
    }

    public static Point[] findClosestPair(Point[] points)
    {
        double minDist = Double.POSITIVE_INFINITY;
        Point p1 = null, p2 = null;

        for (int i = 0; (i < points.length) && (!cancel); i++)
        {
            for (int j = i + 1; (j < points.length) && (!cancel); j++)
            {
                double d = points[i].distanceTo(points[j]);
                if (d < minDist)
                {
                    minDist = d;
                    p1 = points[i];
                    p2 = points[j];
                }
            }
        }

        return new Point[]{p1, p2};
    }
}
